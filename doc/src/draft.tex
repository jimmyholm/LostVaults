\documentclass[a4paper]{article}
\usepackage[swedish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{graphicx}
\DeclareGraphicsExtensions{.png}

\title{The Lost Vaults: Uneasy Alliance\\\small{Operativsystem och multicoreprogrammering (1DT089) våren 2013}\\\small{Slutrapport för grupp 4}}

\author{Felix Färjsjö\\(19911225-4678) \and Jimmy Holm\\(19870928-0138) \and Fredrik Larsson\\(19890422-0590) \and Anna Nilsson\\(19910804-0628) \and Philip Åkerfeldt\\(19920508-1335)}

\date{\today\\Version 1.0}

\begin{document}
\maketitle
\newpage
\tableofcontents
\listoffigures
\newpage
\section{Inledning}
Concurrency är en aspekt inom mjukvaruutveckling som ökar i betydelse då datorer förlitar sig mer och mer på parallell bearbetning och till följd av detta måste vårt sätt att skriva 
program justeras. Denna nya sort av arkitektur medför nya problem och om vi inte anpassar oss kommer denna utökning i kapacitet förbli outnyttjad. För att utforska dessa nya utmaningar 
och dess lösningar, valde vi att arbeta fram ett server-client system över en TCP/IP nätverksuppkoppling. Problemen vi försökte lösa var att upprätthålla en mottaglig miljö för multipla, 
simultana uppkopplingar och samtidigt ha flera aktiva samt oberoende sektioner av programlogik. Vi representerar detta problem genom ett multi-user dungeon eller MUD, 
en sorts online multiplayerspel, där målet var att säkerställa att servern upprätthåller ett stabilt verkställande oavsett antal uppkopplade användare.
    
Vi beslutade att kalla spelet Lost Vaults, ett semi-traditionellt MUD där användaren interagerar med andra spelare och tar del i uppdrag. Detta sker i grupper av flertal spelare som 
tillsammans arbetar mot ett gemensamt mål samtidigt som varje enskild gruppmedlem har en personlig agenda som endast gagnar den enskilda invididen. Möjligheten finns att utforska som 
enskild individ, men fokuset för spelet ligger i den dynamik som följer av interaktionen med andra spelare. Spelet utspelas på två olika platser, i City och i Dungeon; där City är 
staden där spelarna samlas efter tidigare utforskningar, kan fylla på förnödenheter samt forma grupper för att gå ner i Dungeons. Dungeons är en procedurellt genererad uppsättning 
rum fyllt med monster, fällor och skatter. Varje grupp spelare får alltså sin egen unikt genererade Dungeon när gruppen går ner i dessa magiska grottor under staden. Väl inne ges 
gruppen en eller flera uppdrag som bör fullbordas under upptäcksfärden.
  
Som beskrivet nedan i delen om speldesign, finns det två typer av uppdrag: grupp- och spelaruppdrag. Gruppuppdrag gagnar alla spelare i gruppen medan spelaruppdragen gynnar den enskilde. 
Vårt mål var att skapa en atmosfär där spelare behöver lita på varandra för att fullborda de svårare gruppuppdragen, fast samtidigt vara misstänksamma mot varandra då vem som helst kan 
förråda gruppen för att färdigställa sina personliga uppdrag.
 
Den slutgiltiga produkten för detta projekt är ett fullt funktionellt och interaktivt multiplayer online role playing game kallat Lost Vaults.

Relationen mellan konceptet concurrency och vårt projekt är förmågan att ha fler än en spelare aktiva i spelet samtidigt och se hur dessa interagerar med varandra, samt flertalet 
aktiva spelområden körandes samtidigt och oberoende av varandra.

\section{System architecture}
\subsection{Design}
Systemarkitekturen som återfinns i detta dokument är uppdelat i Client-side arkitektur och Server-side arkitektur. Applikation, skriven i Scala, körs i Java Virtual Machine och på 
grund av detta kan både klient och server köras på alla plattformar som stödjer Java VM 1.7.


****** figur 1****




\subsection{Client side}
Målet med designen för klienten till Lost Vaults var att ta fram något som kunde efterliknas med en indirekt terminal, där ingen logik används förutom att skicka förfrågningar och 
motta samt tolka svaren på förfrågningar. I slutänden hoppas vi kunna åstadkomma en client-side implementation som lätt kan utökas när serverns implementation av spelets logik ökar, 
alltså ett system som kan utkökas enkelt endast genom att addera nya förfrågningar och svar.

Som synes i Figur 1 är klientfönstret uppdelat i flera textfält som visar relevant information för spelaren. Huvudområdet är för vanliga server-svar och kommer innehålla beskrivningar 
av rummet, meddelanden i spelarchatten, meddelanden med systeminformation och liknande. Klientens högra sida är reserverat för ständig information som spelaren behöver ta del av snabbt. 
Den övre delen innehåller information om spelarens egen karaktär, där spelarens liv och stridsegenskaper samt hur mycket mat gruppen har listas. 

Den nedre delen av fönstret innehåller kommandoraden, där spelaren skriver in kommandon i enlighet med ett strikt syntax. När klienten startas välkomnas spelaren 
av ett centrerat fönster för inloggning . Här kan spelaren skriva in sitt användarnamn och lösenord samt IP:n till den server som spelaren vill koppla upp sig mot. 

Klientens GUI är implementerat i Javas Swing UI bibliotek och integrerat i Scala för att använda Akkas TCP funktionalitet.

**Figur 2**
    
\subsubsection{Class model}
Klienten är strukturerad i fyra olika distinkta klasser som beskrivs i Figur 2. Klasserna PlayGame och PlayGameCommunication arbetar 
tillsammans för att skapa en brygga mellan TCP lagret och GUI:t, där PlayGame accepterar meddelanden från TCPClient och skickar dem 
vidare till GUI via PlayGameCommunication. Samtidigt så skickas data från GUI över nätverket via metodanrop i PlayGameCommuncation till 
PlayGame för att sedan hamna hos TCPClient.

\subsection{Server side}
Systemarkitekturens serverdel är uppdelad i sektionerna Concurrency Model, Actor Model och Class Model. Den första delen beskriver vårt 
val av concurrencymodell, och anledningen till valet. Den andra delen beskriver funktionen hos de fem stora actor-typer i Lost Vaults servern och 
den tredje ger en ingående beskrivning hur klassförhållanden används av servern.

\subsubsection{Concurrency model}
Actor modellen har använts för projektet då vi under vår initiala diskussion gällande designen lyckades isolera beteenden i mindre och till stor del 
fristående sektioner. Dessa sektioner kunde enkelt skapas för att dela data enbart genom meddelandesändning som i sin tur leder till att problem 
såsom deadlock kunde undvikas. 

För att implementera denna sortens system och bibehålla hög effektivitet valde vi Scala som programspråk till servern av den enkla anledningen att 
skalbarheten är ett av språkets fundamentala mål. Genom rekommendationer av skaparna bakom Scala och via språkets styrkor och enkelhet, beslöt vi 
att använda Akka som vårt aktörbibliotek. Detta för att kunna använda Akkas TCP-bibliotek för nätverkskommunikationen. Bibliotekets enkla integration 
ledde till vårt beslut att använda Scala och Akka som val av programspråk och aktörbibliotek även för klienten, som tidigare nämnts.                    

**Figur 3**

\subsubsection{Actor model}
Serverdelen är uppdelad i flera processer via Akkas aktörbibliotek för att upprätthålla Actor Concurrency Model i enlighet med Figur 3. Bara två typer av aktörer kommmunicerar 
direkt med nätverket via TCP/IP, Connection Manager-aktören och Player-aktörerna. Connection Manager- aktören har som syfte att hantera inkommande uppkopplingar samt ansvarar 
för att skapa Player-aktörer som nya högnivå aktörer innan de registreras som den nyetablerade uppkopplingens lyssnare. Som lyssnare kommer Player-aktören mottaga och skicka data 
över nätverket genom den etablerade uppkopplingen. Player-aktören styr över alla ting relaterat till klienten, som exempelvis spelarens attribut och för att verifiera 
inloggningsförsök via kommunikation med PlayerMap. Det är även via Player-aktören andra aktörer kan skicka meddelanden över nätverket om det skulle behövas. 

PlayerMap-aktören och Groupmap-aktören fyller två specifika funktioner. PlayerMap mappar en sträng, namnet på den uppkopplade spelare, till aktören som kontrollerar 
spelaren med det specifika namnet. Genom denna aktör kan en annan aktör snabbt och enkelt skicka meddelanden till en specifik spelare baserat på dess namn - 
ett viktigt kommando som agerar på följande sätt är exempelvis “WHISPER”. PlayerMap möjliggör även ett snabbt och enkelt sätt för Player-aktören att försäkra 
sig om att det inte existerar flera spelare med samma namn på servern.

GroupMap-aktören fyller en liknande funktion som PlayerMap, men länkar istället namnen på spelarna med spelargrupper istället för spelaraktörer. 
En spelargrupp är en samling av en eller fler spelare som tillsammans kan gå ner i en Dungeon som är procedurellt genererad för just dem. Syftet med 
denna aktör är att underlätta skapandet och att ansluta sig till andra spelargrupper. Genom att använda GroupMap räcker det att ansluta sig till en 
spelare via dess namn för att inkluderas i denna spelares grupp, eller för att skapa en ny grupp med denna spelare.

Den fjärde sortens aktör som servern använder är Dungeon-aktören, den som utför spelets logik. 
Det existerar ett speciellt tillstånd av Dungeon-aktören, kallat City- aktören. City existerar ständigt 
under serverns livstid och hanterar spelets sociala aspekt, såsom chattande och skapandet av grupper. 
Det ordinära fallet som Dungeon-aktören ansvarar för är genererandet och hanterandet av den procedurella 
grottan av multipla, sammanlänkade rum i ett tvådimensionellt rutnät. Det är i dessa rum som spelare kommer kunna göra uppdrag, 
finna skatter etc. Dungeon-aktören ansvarar för koordinerandet av alla spelare som finns i grottan. 
Ett exempel på detta är kommandot “SAY”  som ska skickas till relevanta spelare. 

Efter att City-aktören har skapat Dungeon-aktören ansvarar den för sin egen livslängd och avsutar sig själv endast när det inte längre finns några spelare i den.

**Figur 4**

\subsubsection{Class model}
Figur 4 visar relationen mellan de olika klasserna i implementation av servern och dess multiplicitet av relevanta förhållanden. 
De är uppdelade i tre kategorier; Utility Layer, Network Communicators och Game Logic. 
Utility Layer tillhandahåller understödjande funktionalitet till de andra klasserna och exakt en av varje klass ska existera vid en given punkt. 
Network Communicators är de som relaterar tillbaka till nätverket genom Akkas TCP bibliotek. Connection manager klassen, ConMan, hanteras som en singleton och endast en 
instans av denna ska existera vid en given tidpunkt. Player-klassen har emellertid en instans för varje öppen uppkoppling.

Game Logic delen innehåller alla interna klasser och där också Dungeon-klassen. Dungeon-klassen är bryggan mellan Network 
Communicators och Game Logic och det är endast via en Dungeon-klass som en Player kan utföra någon handling förutom WHISPER kommandot, 
då detta meddelande är över hela servern. Dungeon-klassen håller koll på utforskade och outforskade rum, uppdrag, grupper, object och NPCs. 
Dungeon håller även koll på de Players som för tillfället är uppkopplade och associerade med en given Dungeon.

\section{Utvecklingsverktyg}

I detta projekt användes flera olika verktyg för att underlätta utvecklingen. Då vi använt Scala som vårt val av programspråk skrevs i princip all vår kod i Eclipse. 
Detta då vi anser att det i särklass är det enklaste sättet att utveckla kod till Java eller Scala. Även fast all kod är skriven i Eclipse använder vi Ant Build System 
för automatiserad kompilering samt byggandet av vår klient och server, klar att köras i Java Virtual Machine. 

För hanteringen av versionskontroll har vi använt det tillförlitliga och välkända verktyget Git. Vi satte upp ett nytt git repository på Github.com specifikt för detta 
projekt och valet av Git gjordes på grund av dess styrkor samt att vi är vana användare av det.

Testandet av vår kod görs med ScalaTest ramverket samt ett Ant Build skript som ger oss möjligheten till automatiskt byggande och körning av tester.

Sammansättningen av dokumentationen utförs med Scaladoc på grund av dess likhet med JavaDoc, ett verktyg vi är vana med att använda, och Ant har reviderats för att automatiskt 
bygga vår dokumentation.

\section{Implementation}

\subsection{Programspråk}
Java var det språket vi valde att använda vid skapandet av det grafiska gränssnittet som spelaren agerar mot. Vårt val grundade sig i biblioteket Swing som Java tillhandahåller. 
Med hjälp att detta bibliotek var skapandet av det grafiska gränssnittet en relativt enkel process. Likt många andra av Javas bibliotek var dokumentationen välskriven och enkel 
att använda vilket underlättade processen. En annan aspekt som fick oss att välja Java för just denna del var att vi ville kunna kommunicera med resterande kod, skriven i Scala, 
på ett enkelt sätt och detta kunde uppnås utan problem då Scala är byggt utifrån Javas Virtuella Maskin. 

Anledningen till att vi skrev inte skrev hela projektet i Java var på grund av den bristande skalbarheten som språket besitter. Scala däremot erbjöd båda en liknande syntax som 
Java och hade samtidigt bättre skalbarhet. Detta innebar att övergången mellan att skriva Java och Scala var en någorlunda mjuk sådan, koden var ganska lättigenkännlig och systemet 
kunde utvecklas med skalbarhet i åtanke. Några nackdelar med Scala som vi finner nämnvärda är exempelvis att det, trots likheter med Java, tog en viss tid att sätta sig in i det nya 
språket vilket kan ha motarbetat utvecklingen mot om vi hade valt ett annat språk som vi var mer bekanta med. Det är viktigt att inte glömma att de nackdelar vi funnit under 
projektets gång skuggas av fördelarna vi funnit med språket.

\subsection{Algoritmer}

\subsection{Datastrukturer}

\subsection{Concurrency}
Flera spelare samtidigt


\section{Slutsatser}
Något vi gjorde bra var att vi gjorde klart det essentiella för huvudmålet med projektet, att uppnå concurrency på något sätt. 
Då den delen av projektet var klart kunde vi utöka produkten med funktioner för att göra spelet roligare och mer interaktivt. 
Implementation av föremål och monster att slåss mot i grottan. 
Något vi lärt oss är att skriva nätverkskod. Vi har även fått kunskap i ett nytt programspråk.
Det vi tycker har varit svårt var bland annat att integrationstesta våra aktörer. Svårigheterna uppstod på grund av bristande 
information att ta del av om hur vi skulle gå till väga för att göra detta. En annan sak som också varit relativt svår var att 
begränsa oss när det gällde den utsträckning för vilket spelet skulle utvecklas. Att begränsa utvecklingen till en rimlig nivå för spelet 
och samtidigt ha det tillräckligt intressant för den som spelar.

\section{Appendix}

Scala 2.10.4, Akka 2.3.2, SLF4J 1.7.7, Slick 2.0.2, SQLite JDBC 3.7.2

https://github.com/senilica/LostVaults/

Vilka versioner av till exempel Erlang, Java, Python etc har använts?
Hur kan koden laddas ner? Finns koden tillgänglig på till exempel GitHub eller Bitbucket eller som Tar arkiv?  Beskriv projektets katalogstruktur.
Vilket stöd för automatiserad testning finns och hur används det, till exempel JUnit (Java), EUnint (Erlang) eller PyUnit (Python)?
%Vilket stöd för automatiserad generering av dokumentation finns och hur används det, till exempel Doxygen (C, C++, C\#, Fortran, Java, Objective\­C, PHP, Python), EDoc (Erlang), Pydoc (Python), Javadoc (Java)?
Hur kompileras systemet?
Hur startas systemet? tryck på play


\end{document}
